## Introduction

Test-driven development (TDD) is a programming technique where you write test code before implementation code. Test code is written to define the desired behavior of your program. The test output provides descriptive error messages that inform the implementation of your program.

## The Red-Green-Refactor Cycle

One of the driving forces of TDD is the red-green-refactor cycle. “Red” and “green” correspond to the color of the text that our test framework produces in the terminal while running the tests in our suite. Red signifies failing tests and green corresponds to passing tests.

- Red — Write tests that describe the intended behavior of implementation code, and then compare developer expectations with the actual results of implementation code. The tests should always fail at first because the implementation code for the desired behavior will be written in response to the failing test.
- Green — Write just enough implementation code to make the test pass. The tests return green because the implementation code executes the intended behavior described by the test in the red phase.
- Refactor — Clean up and optimize code following the characteristics of a good test. Refactoring involves actively considering test and implementation code and making revisions to the code base. The tests are passing and should continue to pass throughout this phase of the cycle.

## Getting Into The Red I

When we use the red, green, refactor cycle, we:

Write test code that fails
Write implementation code to make the test pass
Consider refactoring the code
As you learn TDD, it may feel backward to intentionally write and run code that will return errors. In TDD we react to the error messages by continually re-writing our implementation code so it behaves in the way that our test specifies.

Imagine you were trying to create a method named .initials, inside of an object named Phrase.

The desired behavior of .initials() is that it should return the first letter of each word in a phrase that is passed to it as an argument.

### Step 1: Write The Test

The first step to writing a test with Mocha is to use describe and it blocks to describe the desired behavior of your code. It’s very important for tests to thoroughly describe the desired behavior with natural language. This will create the most helpful error messages and make it easy for you to understand the behavior that your test failed in executing.

Before running our test, we would use an assert statement to compare the desired result of our method with the actual result.

The first step in developing this method would be writing a test that could look like this:

```
describe('Phrase', () => {
  describe('.initials', () => {
    it('returns the first letter of each word in a phrase.', () => {
      assert.equal(Phrase.initials('Nelson Mandela'), 'NM');
    })
  })
})
```

### Step 2: Run the test

If we ran this test we would get the following error message

### Step 3: The test fails (yea!)
The error message tells us that the error is related to the Phrase.initials code block. 
The ReferenceError tells us that the error is thrown because we don’t have a Phrase object. 


## Red To Green I

The red error messages describe the failures of our implementation code, so we can specifically address each issue that is preventing our test from passing.
Following TDD, the next step would be writing the minimum possible implementation code to make our test pass.

Let’s look at the error message from our Phrase.initials() example.

The error tells us that Phrase is not defined. This is because we have not created an object named Phrase yet. Let’s do that now:

```
const Phrase = {}
```

We’re still in the red, but we have a new error. The error says that Phrase.initials is not a function. That’s because we haven’t added an .initials method to the Phrase object. Let’s do that now:

```
const Phrase = {
    initials() {
  }
}
```

In this example, that would involve adding a line of implementation code so that .initials() returns our expected result, which is NM.

The minimum possible implementation code to make the test pass:


```
const Phrase = {
  initials(phr) {
    return 'NM';
  }
}
```
Now our test would pass and we would be in the green. But that doesn’t mean our method is working as intended. If we entered “Jody Williams” our method would return ‘NM’, not ‘JW’. We will address this issue when it is time, but following TDD, now that we have progressed from the red to the green, we will move into the refactor phase.

## Refactor I

Once all your tests pass, you can confidently refactor your code — restructure and improve it without changing its external behavior. The confidence comes from knowing that our tests will catch us if we make a misstep.

When refactoring, it’s critical to test early and often — if our tests turn red, then we know that something went wrong while we were refactoring, and we can undo those changes.

A good place to start with refactoring is to restructure tests to reflect the four phases of a good test: setup, exercise, verification, teardown.

Let’s consider the test for our Phrase.initials method. We could rewrite the test with setup, exercise, and verification stages to make it more expressive and maintainable.

```
describe('Phrase', () => {
  describe('.initials', () => {
    it('returns the first letter of each word in a phrase.', () => {
      // Setup
      const inputName = 'Nelson Mandela';
      const expectedInitials = 'NM';
      // Exercise
      const result = Phrase.initials(inputName);
      // Verification
      assert.equal(result, expectedInitials);
    });
  });
});
```

Here, we have re-written the same test, but we have created variables to hold the values that we will use to test the behavior of .initials(), and broken up the test into distinct phases, which are marked by the comments in the code.

Now that we have refactored our test code, we can refactor our implementation code. Our earlier code looked like this:

In order to make our implementation code more expressive, we can change the name of the input argument of .initials() like this:

```
const Phrase = {
  initials(inputName) {
    return 'NM';
  }
}
```
Refactoring will look different for each project and each iteration of the red-green-refactor cycle. In some cases you won’t need to refactor at all! Regardless, you should consider how you can improve your code and — although it is optional — it can set you up for success moving forward.




